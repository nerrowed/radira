"""SQL Injection vulnerability scanner."""

import logging
from typing import List, Dict, Any
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import time

from .base_module import BaseVulnerabilityModule
from ..models import Vulnerability, VulnerabilityType, Severity
from ..ai.payload_generator import AIPayloadGenerator

logger = logging.getLogger(__name__)


class SQLInjectionScanner(BaseVulnerabilityModule):
    """Scanner for SQL injection vulnerabilities."""

    def __init__(self, http_client, payload_generator: AIPayloadGenerator):
        """Initialize scanner.

        Args:
            http_client: HTTP client
            payload_generator: AI payload generator
        """
        super().__init__(http_client)
        self.payload_generator = payload_generator

    @property
    def name(self) -> str:
        return "SQL Injection Scanner"

    def scan(self, url: str, **kwargs) -> List[Vulnerability]:
        """Scan for SQL injection vulnerabilities.

        Args:
            url: URL to scan
            **kwargs: Additional parameters

        Returns:
            List of vulnerabilities found
        """
        vulnerabilities = []

        # Parse URL and extract parameters
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)

        if not params:
            logger.debug(f"No parameters found in URL: {url}")
            return vulnerabilities

        # Test each parameter
        for param_name, param_values in params.items():
            logger.info(f"Testing parameter: {param_name}")

            # Get context for AI payload generation
            context = kwargs.get("context", "")

            # Generate payloads
            payloads = self.payload_generator.generate_sql_injection_payloads(
                parameter=param_name,
                context=context
            )

            # Test each payload
            for payload in payloads:
                vuln = self._test_parameter(
                    url=url,
                    param_name=param_name,
                    payload=payload,
                    original_value=param_values[0] if param_values else ""
                )

                if vuln:
                    vulnerabilities.append(vuln)
                    logger.warning(f"SQL Injection found in {param_name}: {payload}")
                    break  # Stop after first successful injection per parameter

                # Rate limiting
                time.sleep(0.1)

        return vulnerabilities

    def _test_parameter(
        self,
        url: str,
        param_name: str,
        payload: str,
        original_value: str
    ) -> Vulnerability | None:
        """Test a parameter with a payload.

        Args:
            url: Target URL
            param_name: Parameter name
            payload: Injection payload
            original_value: Original parameter value

        Returns:
            Vulnerability if found, None otherwise
        """
        # Build test URL
        test_url = self._build_test_url(url, param_name, payload)

        # Send request
        response = self.http_client.get(test_url)

        if not response:
            return None

        # Check for SQL errors (error-based detection)
        if self._is_error_response(response.text):
            return Vulnerability(
                type=VulnerabilityType.SQL_INJECTION,
                severity=Severity.HIGH,
                url=url,
                description=f"SQL Injection vulnerability detected in parameter '{param_name}'. "
                           f"The application returns SQL error messages, indicating potential SQL injection.",
                evidence=f"SQL error found in response",
                payload=payload,
                parameter=param_name,
                request=test_url,
                response=response.text[:500],
                remediation="Use parameterized queries (prepared statements) instead of concatenating user input into SQL queries. "
                           "Implement input validation and use ORM frameworks where possible.",
                cwe="CWE-89",
                cvss_score=8.2
            )

        # Check for boolean-based blind SQL injection
        if payload in ["' AND '1'='1", "1' AND '1'='1"]:
            # Test with true condition
            true_response = response

            # Test with false condition
            false_payload = payload.replace("'1'='1", "'1'='2")
            false_url = self._build_test_url(url, param_name, false_payload)
            false_response = self.http_client.get(false_url)

            if false_response and len(true_response.text) != len(false_response.text):
                # Different response lengths suggest boolean-based injection
                return Vulnerability(
                    type=VulnerabilityType.SQL_INJECTION,
                    severity=Severity.HIGH,
                    url=url,
                    description=f"Boolean-based blind SQL Injection detected in parameter '{param_name}'. "
                               f"Different responses for true/false conditions.",
                    evidence=f"True condition length: {len(true_response.text)}, "
                            f"False condition length: {len(false_response.text)}",
                    payload=payload,
                    parameter=param_name,
                    request=test_url,
                    remediation="Use parameterized queries and input validation.",
                    cwe="CWE-89",
                    cvss_score=8.0
                )

        # Check for time-based blind SQL injection
        if "SLEEP" in payload.upper() or "WAITFOR" in payload.upper():
            start_time = time.time()
            response = self.http_client.get(test_url)
            elapsed = time.time() - start_time

            if elapsed >= 4:  # If response takes >= 4 seconds (we injected 5s delay)
                return Vulnerability(
                    type=VulnerabilityType.SQL_INJECTION,
                    severity=Severity.HIGH,
                    url=url,
                    description=f"Time-based blind SQL Injection detected in parameter '{param_name}'. "
                               f"The application is vulnerable to time delays.",
                    evidence=f"Response time: {elapsed:.2f} seconds",
                    payload=payload,
                    parameter=param_name,
                    request=test_url,
                    remediation="Use parameterized queries and input validation.",
                    cwe="CWE-89",
                    cvss_score=7.5
                )

        return None

    @staticmethod
    def _build_test_url(url: str, param_name: str, payload: str) -> str:
        """Build test URL with injected payload.

        Args:
            url: Original URL
            param_name: Parameter to inject
            payload: Injection payload

        Returns:
            Test URL
        """
        parsed = urlparse(url)
        params = parse_qs(parsed.query)

        # Replace parameter value with payload
        params[param_name] = [payload]

        # Rebuild query string
        new_query = urlencode(params, doseq=True)

        # Rebuild URL
        return urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            new_query,
            parsed.fragment
        ))
