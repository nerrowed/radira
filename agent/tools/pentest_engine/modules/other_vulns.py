"""Other common vulnerability scanners (SSRF, LFI, Command Injection, etc.)."""

import logging
from typing import List
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import time
import re

from .base_module import BaseVulnerabilityModule
from ..models import Vulnerability, VulnerabilityType, Severity
from ..ai.payload_generator import AIPayloadGenerator

logger = logging.getLogger(__name__)


class SSRFScanner(BaseVulnerabilityModule):
    """Scanner for Server-Side Request Forgery vulnerabilities."""

    def __init__(self, http_client, payload_generator: AIPayloadGenerator):
        super().__init__(http_client)
        self.payload_generator = payload_generator

    @property
    def name(self) -> str:
        return "SSRF Scanner"

    def scan(self, url: str, **kwargs) -> List[Vulnerability]:
        """Scan for SSRF vulnerabilities."""
        vulnerabilities = []
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)

        if not params:
            return vulnerabilities

        for param_name in params.keys():
            payloads = self.payload_generator.generate_ssrf_payloads(url)

            for payload in payloads:
                test_url = self._build_test_url(url, param_name, payload)
                response = self.http_client.get(test_url, timeout=10)

                if response and self._detect_ssrf(response.text, payload):
                    vulnerabilities.append(Vulnerability(
                        type=VulnerabilityType.SSRF,
                        severity=Severity.HIGH,
                        url=url,
                        description=f"Server-Side Request Forgery detected in parameter '{param_name}'. "
                                   f"The server makes requests to attacker-controlled URLs.",
                        evidence=f"SSRF indicators found for payload: {payload}",
                        payload=payload,
                        parameter=param_name,
                        request=test_url,
                        response=response.text[:500],
                        remediation="Validate and whitelist allowed URLs/domains. Disable unused URL schemas. "
                                   "Use network segmentation to restrict internal access.",
                        cwe="CWE-918",
                        cvss_score=8.5
                    ))
                    break

                time.sleep(0.1)

        return vulnerabilities

    @staticmethod
    def _detect_ssrf(response: str, payload: str) -> bool:
        """Detect SSRF indicators in response."""
        ssrf_indicators = [
            "169.254.169.254",  # AWS metadata
            "metadata.google.internal",  # GCP metadata
            "root:",  # /etc/passwd content
            "localhost",
            "127.0.0.1",
            "ami-id",  # AWS metadata fields
            "instance-id",
        ]

        response_lower = response.lower()
        return any(indicator.lower() in response_lower for indicator in ssrf_indicators)

    @staticmethod
    def _build_test_url(url: str, param_name: str, payload: str) -> str:
        """Build test URL with SSRF payload."""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        params[param_name] = [payload]
        new_query = urlencode(params, doseq=True)
        return urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))


class LFIScanner(BaseVulnerabilityModule):
    """Scanner for Local File Inclusion vulnerabilities."""

    def __init__(self, http_client, payload_generator: AIPayloadGenerator):
        super().__init__(http_client)
        self.payload_generator = payload_generator

    @property
    def name(self) -> str:
        return "LFI Scanner"

    def scan(self, url: str, **kwargs) -> List[Vulnerability]:
        """Scan for LFI vulnerabilities."""
        vulnerabilities = []
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)

        if not params:
            return vulnerabilities

        for param_name in params.keys():
            payloads = self.payload_generator.generate_lfi_payloads()

            for payload in payloads:
                test_url = self._build_test_url(url, param_name, payload)
                response = self.http_client.get(test_url)

                if response and self._detect_lfi(response.text):
                    vulnerabilities.append(Vulnerability(
                        type=VulnerabilityType.LFI,
                        severity=Severity.HIGH,
                        url=url,
                        description=f"Local File Inclusion detected in parameter '{param_name}'. "
                                   f"The application includes files based on user input.",
                        evidence=self._extract_lfi_evidence(response.text),
                        payload=payload,
                        parameter=param_name,
                        request=test_url,
                        response=response.text[:500],
                        remediation="Use whitelisting for file paths. Avoid passing user input directly to file operations. "
                                   "Use indirect object references. Implement strict input validation.",
                        cwe="CWE-98",
                        cvss_score=7.5
                    ))
                    break

                time.sleep(0.1)

        return vulnerabilities

    @staticmethod
    def _detect_lfi(response: str) -> bool:
        """Detect LFI indicators in response."""
        lfi_indicators = [
            "root:x:",  # /etc/passwd
            "; for 16-bit app support",  # win.ini
            "[extensions]",  # win.ini
            "[fonts]",  # win.ini
        ]

        return any(indicator in response for indicator in lfi_indicators)

    @staticmethod
    def _extract_lfi_evidence(response: str) -> str:
        """Extract evidence from LFI response."""
        if "root:x:" in response:
            return "/etc/passwd file content detected"
        elif "[extensions]" in response or "[fonts]" in response:
            return "win.ini file content detected"
        return "File inclusion indicators found"

    @staticmethod
    def _build_test_url(url: str, param_name: str, payload: str) -> str:
        """Build test URL with LFI payload."""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        params[param_name] = [payload]
        new_query = urlencode(params, doseq=True)
        return urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))


class CommandInjectionScanner(BaseVulnerabilityModule):
    """Scanner for Command Injection vulnerabilities."""

    def __init__(self, http_client, payload_generator: AIPayloadGenerator):
        super().__init__(http_client)
        self.payload_generator = payload_generator

    @property
    def name(self) -> str:
        return "Command Injection Scanner"

    def scan(self, url: str, **kwargs) -> List[Vulnerability]:
        """Scan for command injection vulnerabilities."""
        vulnerabilities = []
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)

        if not params:
            return vulnerabilities

        for param_name in params.keys():
            payloads = self.payload_generator.generate_command_injection_payloads(param_name)

            for payload in payloads:
                test_url = self._build_test_url(url, param_name, payload)
                response = self.http_client.get(test_url)

                if response and self._detect_command_injection(response.text, payload):
                    vulnerabilities.append(Vulnerability(
                        type=VulnerabilityType.COMMAND_INJECTION,
                        severity=Severity.CRITICAL,
                        url=url,
                        description=f"Command Injection detected in parameter '{param_name}'. "
                                   f"The application executes system commands based on user input.",
                        evidence=self._extract_command_evidence(response.text, payload),
                        payload=payload,
                        parameter=param_name,
                        request=test_url,
                        response=response.text[:500],
                        remediation="Never pass user input directly to system commands. Use parameterized APIs. "
                                   "Implement strict input validation and use whitelisting. Avoid shell execution.",
                        cwe="CWE-78",
                        cvss_score=9.8
                    ))
                    break

                time.sleep(0.1)

        return vulnerabilities

    @staticmethod
    def _detect_command_injection(response: str, payload: str) -> bool:
        """Detect command injection indicators in response."""
        # Check for common command outputs
        command_indicators = [
            "uid=",  # whoami/id output
            "gid=",  # id output
            "root:",  # passwd file
            "total ",  # ls output
            "drwxr",  # ls -l output
            "bin",  # common directory
            "etc",
            "var",
        ]

        response_lower = response.lower()

        # Check if command output is in response
        if any(indicator.lower() in response_lower for indicator in command_indicators):
            return True

        # Check for error messages that might indicate command execution
        error_indicators = [
            "sh:",
            "bash:",
            "command not found",
            "syntax error",
        ]

        return any(error in response_lower for error in error_indicators)

    @staticmethod
    def _extract_command_evidence(response: str, payload: str) -> str:
        """Extract evidence from command injection response."""
        if "uid=" in response:
            return "System user information detected (whoami/id command executed)"
        elif "root:" in response:
            return "/etc/passwd content detected"
        elif any(x in response.lower() for x in ["drwxr", "total "]):
            return "Directory listing detected (ls command executed)"
        return "Command execution indicators found"

    @staticmethod
    def _build_test_url(url: str, param_name: str, payload: str) -> str:
        """Build test URL with command injection payload."""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        params[param_name] = [payload]
        new_query = urlencode(params, doseq=True)
        return urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))


class OpenRedirectScanner(BaseVulnerabilityModule):
    """Scanner for Open Redirect vulnerabilities."""

    def __init__(self, http_client):
        super().__init__(http_client)

    @property
    def name(self) -> str:
        return "Open Redirect Scanner"

    def scan(self, url: str, **kwargs) -> List[Vulnerability]:
        """Scan for open redirect vulnerabilities."""
        vulnerabilities = []
        parsed_url = urlparse(url)
        params = parse_qs(parsed.query)

        # Common redirect parameter names
        redirect_params = ['redirect', 'url', 'next', 'return', 'ReturnUrl', 'goto', 'continue', 'dest', 'destination']

        for param_name in params.keys():
            if any(redir in param_name.lower() for redir in redirect_params):
                payloads = [
                    "http://evil.com",
                    "https://evil.com",
                    "//evil.com",
                    "evil.com",
                ]

                for payload in payloads:
                    test_url = self._build_test_url(url, param_name, payload)
                    response = self.http_client.get(test_url, allow_redirects=False)

                    if response and self._is_redirect(response, payload):
                        vulnerabilities.append(Vulnerability(
                            type=VulnerabilityType.OPEN_REDIRECT,
                            severity=Severity.MEDIUM,
                            url=url,
                            description=f"Open Redirect detected in parameter '{param_name}'. "
                                       f"The application redirects to user-controlled URLs.",
                            evidence=f"Redirect to: {response.headers.get('Location', 'N/A')}",
                            payload=payload,
                            parameter=param_name,
                            request=test_url,
                            remediation="Validate redirect URLs against a whitelist. Use indirect references. "
                                       "Avoid using user input directly in redirect headers.",
                            cwe="CWE-601",
                            cvss_score=6.1
                        ))
                        break

                    time.sleep(0.1)

        return vulnerabilities

    @staticmethod
    def _is_redirect(response, payload: str) -> bool:
        """Check if response is a redirect to the payload URL."""
        if response.status_code in [301, 302, 303, 307, 308]:
            location = response.headers.get('Location', '')
            # Check if location contains our payload domain
            return 'evil.com' in location

        return False

    @staticmethod
    def _build_test_url(url: str, param_name: str, payload: str) -> str:
        """Build test URL."""
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        params[param_name] = [payload]
        new_query = urlencode(params, doseq=True)
        return urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))
