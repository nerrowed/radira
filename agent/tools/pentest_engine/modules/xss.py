"""Cross-Site Scripting (XSS) vulnerability scanner."""

import logging
from typing import List
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import time
import re

from .base_module import BaseVulnerabilityModule
from ..models import Vulnerability, VulnerabilityType, Severity
from ..ai.payload_generator import AIPayloadGenerator

logger = logging.getLogger(__name__)


class XSSScanner(BaseVulnerabilityModule):
    """Scanner for XSS vulnerabilities."""

    def __init__(self, http_client, payload_generator: AIPayloadGenerator):
        """Initialize scanner.

        Args:
            http_client: HTTP client
            payload_generator: AI payload generator
        """
        super().__init__(http_client)
        self.payload_generator = payload_generator

    @property
    def name(self) -> str:
        return "XSS Scanner"

    def scan(self, url: str, **kwargs) -> List[Vulnerability]:
        """Scan for XSS vulnerabilities.

        Args:
            url: URL to scan
            **kwargs: Additional parameters

        Returns:
            List of vulnerabilities found
        """
        vulnerabilities = []

        # Parse URL and extract parameters
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)

        if not params:
            logger.debug(f"No parameters found in URL: {url}")
            return vulnerabilities

        # Test each parameter
        for param_name, param_values in params.items():
            logger.info(f"Testing parameter for XSS: {param_name}")

            # Get context
            context = kwargs.get("context", "")

            # Generate payloads
            payloads = self.payload_generator.generate_xss_payloads(
                parameter=param_name,
                context=context
            )

            # Test each payload
            for payload in payloads:
                vuln = self._test_parameter(
                    url=url,
                    param_name=param_name,
                    payload=payload
                )

                if vuln:
                    vulnerabilities.append(vuln)
                    logger.warning(f"XSS found in {param_name}: {payload}")
                    # Continue testing to find other types of XSS

                # Rate limiting
                time.sleep(0.1)

        return vulnerabilities

    def _test_parameter(
        self,
        url: str,
        param_name: str,
        payload: str
    ) -> Vulnerability | None:
        """Test a parameter with an XSS payload.

        Args:
            url: Target URL
            param_name: Parameter name
            payload: XSS payload

        Returns:
            Vulnerability if found, None otherwise
        """
        # Build test URL
        test_url = self._build_test_url(url, param_name, payload)

        # Send request
        response = self.http_client.get(test_url)

        if not response:
            return None

        # Check if payload is reflected in response
        if self._is_payload_reflected(payload, response.text):
            # Determine XSS type
            xss_type, severity = self._determine_xss_type(payload, response.text)

            return Vulnerability(
                type=xss_type,
                severity=severity,
                url=url,
                description=f"{xss_type.value.upper()} vulnerability detected in parameter '{param_name}'. "
                           f"User input is reflected in the response without proper sanitization.",
                evidence=f"Payload '{payload}' found in response",
                payload=payload,
                parameter=param_name,
                request=test_url,
                response=self._extract_payload_context(payload, response.text),
                remediation="Implement proper output encoding/escaping for all user-controlled data. "
                           "Use Content Security Policy (CSP) headers. Validate and sanitize all input. "
                           "Use modern frameworks with built-in XSS protection.",
                cwe="CWE-79",
                cvss_score=7.1 if severity == Severity.HIGH else 5.4
            )

        return None

    @staticmethod
    def _build_test_url(url: str, param_name: str, payload: str) -> str:
        """Build test URL with XSS payload.

        Args:
            url: Original URL
            param_name: Parameter to inject
            payload: XSS payload

        Returns:
            Test URL
        """
        parsed = urlparse(url)
        params = parse_qs(parsed.query)

        # Replace parameter value with payload
        params[param_name] = [payload]

        # Rebuild query string
        new_query = urlencode(params, doseq=True)

        # Rebuild URL
        return urlunparse((
            parsed.scheme,
            parsed.netloc,
            parsed.path,
            parsed.params,
            new_query,
            parsed.fragment
        ))

    @staticmethod
    def _is_payload_reflected(payload: str, response: str) -> bool:
        """Check if payload is reflected in response.

        Args:
            payload: XSS payload
            response: Response text

        Returns:
            True if reflected
        """
        # Check for exact match
        if payload in response:
            return True

        # Check for HTML-encoded version
        html_encoded = (payload.replace('<', '&lt;')
                              .replace('>', '&gt;')
                              .replace('"', '&quot;')
                              .replace("'", '&#x27;'))

        if html_encoded in response:
            return False  # Encoded = safe

        # Check for partial reflection (script tags)
        if '<script>' in payload.lower() and '<script>' in response.lower():
            return True

        # Check for event handlers
        event_handlers = ['onerror', 'onload', 'onclick', 'onfocus', 'onmouseover']
        for handler in event_handlers:
            if handler in payload.lower() and handler in response.lower():
                return True

        return False

    @staticmethod
    def _determine_xss_type(payload: str, response: str) -> tuple[VulnerabilityType, Severity]:
        """Determine XSS type based on payload and response.

        Args:
            payload: XSS payload
            response: Response text

        Returns:
            Tuple of (XSS type, severity)
        """
        # Check if it's a DOM-based XSS indicator
        if 'document.' in payload or 'window.' in payload:
            return VulnerabilityType.XSS_DOM, Severity.MEDIUM

        # Check if payload is in JavaScript context
        script_pattern = re.compile(r'<script[^>]*>.*?' + re.escape(payload) + r'.*?</script>', re.DOTALL | re.IGNORECASE)
        if script_pattern.search(response):
            return VulnerabilityType.XSS_REFLECTED, Severity.HIGH

        # Check if it's in HTML attribute
        attr_pattern = re.compile(r'<[^>]*\s+[^>]*=' + re.escape(payload), re.IGNORECASE)
        if attr_pattern.search(response):
            return VulnerabilityType.XSS_REFLECTED, Severity.HIGH

        # Default to reflected XSS
        return VulnerabilityType.XSS_REFLECTED, Severity.HIGH

    @staticmethod
    def _extract_payload_context(payload: str, response: str, context_size: int = 200) -> str:
        """Extract context around payload in response.

        Args:
            payload: Payload to find
            response: Response text
            context_size: Characters to include before/after

        Returns:
            Context string
        """
        try:
            index = response.index(payload)
            start = max(0, index - context_size)
            end = min(len(response), index + len(payload) + context_size)
            context = response[start:end]
            return f"...{context}..."
        except ValueError:
            return response[:500]  # Fallback
