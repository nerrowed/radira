"""Reconnaissance engine for target information gathering."""

import logging
import socket
import re
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse

from ..models import ReconData
from ..http_client import HTTPClient

logger = logging.getLogger(__name__)


class ReconEngine:
    """Reconnaissance and information gathering engine."""

    def __init__(self, http_client: HTTPClient):
        """Initialize reconnaissance engine.

        Args:
            http_client: HTTP client instance
        """
        self.http_client = http_client

    def gather(self, target: str) -> ReconData:
        """Gather reconnaissance information about target.

        Args:
            target: Target URL or domain

        Returns:
            ReconData object
        """
        logger.info(f"Gathering reconnaissance data for {target}")

        # Parse target
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"

        parsed = urlparse(target)
        domain = parsed.netloc or parsed.path

        recon_data = ReconData(target=domain)

        # DNS information
        logger.info("Gathering DNS information...")
        recon_data.dns_records = self._get_dns_records(domain)

        # HTTP headers and tech stack
        logger.info("Analyzing HTTP response...")
        headers, tech_stack = self._analyze_http_response(target)
        recon_data.headers = headers
        recon_data.tech_stack = tech_stack

        # Discover endpoints
        logger.info("Discovering endpoints...")
        recon_data.endpoints = self._discover_endpoints(target)

        # Extract forms
        logger.info("Extracting forms...")
        recon_data.forms = self._extract_forms(target)

        logger.info(f"Reconnaissance complete for {target}")
        return recon_data

    def _get_dns_records(self, domain: str) -> Dict[str, List[str]]:
        """Get DNS records for domain.

        Args:
            domain: Domain name

        Returns:
            Dictionary of DNS records
        """
        dns_records = {}

        try:
            # A record (IPv4)
            ipv4 = socket.gethostbyname(domain)
            dns_records['A'] = [ipv4]
            logger.info(f"Found A record: {ipv4}")
        except socket.gaierror:
            logger.warning(f"Could not resolve A record for {domain}")
            dns_records['A'] = []

        try:
            # Get all addresses (includes IPv6 if available)
            addr_info = socket.getaddrinfo(domain, None)
            ipv6_addrs = [info[4][0] for info in addr_info if ':' in info[4][0]]
            if ipv6_addrs:
                dns_records['AAAA'] = list(set(ipv6_addrs))
                logger.info(f"Found AAAA records: {ipv6_addrs}")
        except socket.gaierror:
            dns_records['AAAA'] = []

        return dns_records

    def _analyze_http_response(self, url: str) -> tuple[Dict[str, str], List[str]]:
        """Analyze HTTP response for headers and technology detection.

        Args:
            url: Target URL

        Returns:
            Tuple of (headers dict, tech stack list)
        """
        headers = {}
        tech_stack = []

        response = self.http_client.get(url)
        if not response:
            return headers, tech_stack

        # Extract security headers
        security_headers = [
            'X-Frame-Options',
            'X-Content-Type-Options',
            'X-XSS-Protection',
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'X-Powered-By',
            'Server',
            'Set-Cookie'
        ]

        for header in security_headers:
            if header in response.headers:
                headers[header] = response.headers[header]

        # Detect technologies
        tech_stack = self._detect_technologies(response)

        return headers, tech_stack

    @staticmethod
    def _detect_technologies(response) -> List[str]:
        """Detect technologies from HTTP response.

        Args:
            response: HTTP response object

        Returns:
            List of detected technologies
        """
        technologies = []

        # Check headers
        server = response.headers.get('Server', '')
        if server:
            technologies.append(f"Server: {server}")

        x_powered_by = response.headers.get('X-Powered-By', '')
        if x_powered_by:
            technologies.append(f"Powered-By: {x_powered_by}")

        # Check response body for framework indicators
        body = response.text.lower()

        frameworks = {
            'WordPress': ['wp-content', 'wp-includes'],
            'Drupal': ['drupal.js', 'sites/all/'],
            'Joomla': ['joomla', 'option=com_'],
            'Laravel': ['laravel', '_token'],
            'Django': ['csrfmiddlewaretoken', '__admin__'],
            'Flask': ['flask'],
            'Express.js': ['express'],
            'React': ['react', '__react'],
            'Vue.js': ['vue.js', 'vue.min.js'],
            'Angular': ['ng-app', 'angular'],
            'jQuery': ['jquery'],
            'Bootstrap': ['bootstrap'],
        }

        for framework, indicators in frameworks.items():
            if any(indicator in body for indicator in indicators):
                technologies.append(framework)

        return technologies

    def _discover_endpoints(self, url: str, max_endpoints: int = 50) -> List[str]:
        """Discover common endpoints and paths.

        Args:
            url: Base URL
            max_endpoints: Maximum endpoints to return

        Returns:
            List of discovered endpoints
        """
        endpoints = []

        # Common paths to check
        common_paths = [
            '/admin',
            '/login',
            '/api',
            '/robots.txt',
            '/sitemap.xml',
            '/.git/config',
            '/.env',
            '/backup',
            '/uploads',
            '/wp-admin',
            '/phpmyadmin',
            '/dashboard',
            '/config',
            '/api/v1',
            '/api/v2',
        ]

        base_url = HTTPClient.get_base_url(url)

        for path in common_paths:
            endpoint_url = HTTPClient.join_url(base_url, path)
            response = self.http_client.get(endpoint_url)

            if response and response.status_code in [200, 301, 302, 401, 403]:
                endpoints.append(f"{path} ({response.status_code})")
                logger.info(f"Found endpoint: {path} ({response.status_code})")

            if len(endpoints) >= max_endpoints:
                break

        return endpoints

    def _extract_forms(self, url: str) -> List[Dict[str, Any]]:
        """Extract forms from page.

        Args:
            url: Target URL

        Returns:
            List of form dictionaries
        """
        forms = []

        response = self.http_client.get(url)
        if not response:
            return forms

        # Simple form extraction using regex
        form_pattern = re.compile(r'<form[^>]*>(.*?)</form>', re.DOTALL | re.IGNORECASE)
        form_matches = form_pattern.findall(response.text)

        for form_html in form_matches[:10]:  # Limit to 10 forms
            form_data = {
                'action': '',
                'method': 'GET',
                'inputs': []
            }

            # Extract action
            action_match = re.search(r'action=["\'](.*?)["\']', form_html, re.IGNORECASE)
            if action_match:
                form_data['action'] = action_match.group(1)

            # Extract method
            method_match = re.search(r'method=["\'](.*?)["\']', form_html, re.IGNORECASE)
            if method_match:
                form_data['method'] = method_match.group(1).upper()

            # Extract inputs
            input_pattern = re.compile(r'<input[^>]*>', re.IGNORECASE)
            inputs = input_pattern.findall(form_html)

            for input_tag in inputs:
                name_match = re.search(r'name=["\'](.*?)["\']', input_tag, re.IGNORECASE)
                type_match = re.search(r'type=["\'](.*?)["\']', input_tag, re.IGNORECASE)

                if name_match:
                    input_data = {
                        'name': name_match.group(1),
                        'type': type_match.group(1) if type_match else 'text'
                    }
                    form_data['inputs'].append(input_data)

            forms.append(form_data)

        return forms
