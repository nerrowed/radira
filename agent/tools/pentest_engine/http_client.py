"""HTTP client for vulnerability scanning."""

import logging
import requests
from typing import Optional, Dict, Any
from urllib.parse import urlparse, urljoin

logger = logging.getLogger(__name__)


class HTTPClient:
    """HTTP client with scanning-specific features."""

    def __init__(
        self,
        timeout: int = 30,
        verify_ssl: bool = False,
        proxies: Optional[Dict[str, str]] = None,
        custom_headers: Optional[Dict[str, str]] = None,
        cookies: Optional[Dict[str, str]] = None
    ):
        """Initialize HTTP client.

        Args:
            timeout: Request timeout in seconds
            verify_ssl: Whether to verify SSL certificates
            proxies: Proxy configuration
            custom_headers: Custom headers to include
            cookies: Cookies to include
        """
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.proxies = proxies or {}
        self.custom_headers = custom_headers or {}
        self.cookies = cookies or {}

        # Default headers
        self.default_headers = {
            "User-Agent": "RADIRA-Pentest/1.0 (Security Scanner)",
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.9",
            "Accept-Encoding": "gzip, deflate"
        }

        # Suppress SSL warnings
        if not verify_ssl:
            requests.packages.urllib3.disable_warnings()

    def get(self, url: str, **kwargs) -> Optional[requests.Response]:
        """Perform GET request.

        Args:
            url: Target URL
            **kwargs: Additional requests arguments

        Returns:
            Response object or None on error
        """
        return self._request("GET", url, **kwargs)

    def post(self, url: str, data: Any = None, **kwargs) -> Optional[requests.Response]:
        """Perform POST request.

        Args:
            url: Target URL
            data: POST data
            **kwargs: Additional requests arguments

        Returns:
            Response object or None on error
        """
        return self._request("POST", url, data=data, **kwargs)

    def _request(
        self,
        method: str,
        url: str,
        **kwargs
    ) -> Optional[requests.Response]:
        """Perform HTTP request with error handling.

        Args:
            method: HTTP method
            url: Target URL
            **kwargs: Additional requests arguments

        Returns:
            Response object or None on error
        """
        try:
            # Merge headers
            headers = {**self.default_headers, **self.custom_headers}
            if "headers" in kwargs:
                headers.update(kwargs.pop("headers"))

            # Merge cookies
            cookies = {**self.cookies}
            if "cookies" in kwargs:
                cookies.update(kwargs.pop("cookies"))

            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                cookies=cookies,
                proxies=self.proxies,
                timeout=self.timeout,
                verify=self.verify_ssl,
                allow_redirects=kwargs.pop("allow_redirects", True),
                **kwargs
            )

            return response

        except requests.exceptions.Timeout:
            logger.warning(f"Request timeout for {url}")
            return None
        except requests.exceptions.ConnectionError:
            logger.warning(f"Connection error for {url}")
            return None
        except requests.exceptions.TooManyRedirects:
            logger.warning(f"Too many redirects for {url}")
            return None
        except Exception as e:
            logger.error(f"Request error for {url}: {e}")
            return None

    @staticmethod
    def is_valid_url(url: str) -> bool:
        """Check if URL is valid.

        Args:
            url: URL to validate

        Returns:
            True if valid
        """
        try:
            result = urlparse(url)
            return all([result.scheme, result.netloc])
        except Exception:
            return False

    @staticmethod
    def get_base_url(url: str) -> str:
        """Get base URL (scheme + netloc).

        Args:
            url: Full URL

        Returns:
            Base URL
        """
        parsed = urlparse(url)
        return f"{parsed.scheme}://{parsed.netloc}"

    @staticmethod
    def join_url(base: str, path: str) -> str:
        """Join base URL with path.

        Args:
            base: Base URL
            path: Path to join

        Returns:
            Joined URL
        """
        return urljoin(base, path)
