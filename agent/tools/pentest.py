"""Penetration testing tools for security assessments."""

import subprocess
import shlex
import logging
from typing import Dict, List, Any, Optional
from pathlib import Path

from .base import BaseTool, ToolResult, ToolStatus, ToolExecutionError
from config.settings import settings

logger = logging.getLogger(__name__)


class PentestTool(BaseTool):
    """Tool for penetration testing and security assessment.

    Supports: SQLMap, ffuf, nmap, gospider
    """

    SUPPORTED_TOOLS = {
        "nmap": {
            "description": "Network port scanner",
            "check_command": ["nmap", "--version"],
        },
        "sqlmap": {
            "description": "SQL injection testing tool",
            "check_command": ["sqlmap", "--version"],
        },
        "ffuf": {
            "description": "Fast web fuzzer",
            "check_command": ["ffuf", "-V"],
        },
        "gospider": {
            "description": "Fast web spider",
            "check_command": ["gospider", "-h"],
        },
        "nuclei": {
            "description": "Vulnerability scanner",
            "check_command": ["nuclei", "-version"],
        },
        "subfinder": {
            "description": "Subdomain discovery",
            "check_command": ["subfinder", "-version"],
        },
        "httpx": {
            "description": "HTTP toolkit",
            "check_command": ["httpx", "-version"],
        }
    }

    def __init__(self, working_directory: Optional[str] = None):
        """Initialize pentest tool.

        Args:
            working_directory: Working directory for outputs
        """
        super().__init__()
        self.working_dir = Path(working_directory or settings.working_directory) / "pentest_output"
        self.working_dir.mkdir(parents=True, exist_ok=True)

        # Check which tools are available
        self.available_tools = self._check_available_tools()

    def _check_available_tools(self) -> Dict[str, bool]:
        """Check which pentest tools are installed.

        Returns:
            Dict mapping tool name to availability
        """
        available = {}
        for tool_name, tool_info in self.SUPPORTED_TOOLS.items():
            try:
                result = subprocess.run(
                    tool_info["check_command"],
                    capture_output=True,
                    timeout=5,
                    text=True
                )
                available[tool_name] = result.returncode == 0
                if available[tool_name]:
                    logger.info(f"Pentest tool available: {tool_name}")
            except (subprocess.TimeoutExpired, FileNotFoundError):
                available[tool_name] = False
                logger.debug(f"Pentest tool not found: {tool_name}")

        return available

    @property
    def name(self) -> str:
        return "pentest"

    @property
    def description(self) -> str:
        available_list = [name for name, avail in self.available_tools.items() if avail]
        available_str = ", ".join(available_list) if available_list else "none installed"

        return f"""Execute penetration testing and security assessment tools.

Available tools: {available_str}

Supports: nmap, sqlmap, ffuf, gospider, nuclei, subfinder, httpx
"""

    @property
    def parameters(self) -> Dict[str, Any]:
        return {
            "tool": {
                "type": "string",
                "description": "Tool to use: nmap, sqlmap, ffuf, gospider, nuclei, subfinder, httpx",
                "required": True
            },
            "target": {
                "type": "string",
                "description": "Target URL/IP/domain",
                "required": True
            },
            "args": {
                "type": "string",
                "description": "Tool arguments (without tool name and target)",
                "required": False
            },
            "output_file": {
                "type": "string",
                "description": "Output filename (saved to pentest_output/)",
                "required": False
            }
        }

    @property
    def category(self) -> str:
        return "security"

    @property
    def examples(self) -> List[str]:
        return [
            "Port scan: {'tool': 'nmap', 'target': '192.168.1.1', 'args': '-sV -p 80,443'}",
            "SQLi test: {'tool': 'sqlmap', 'target': 'http://target.com/page?id=1', 'args': '--batch --dbs'}",
            "Fuzzing: {'tool': 'ffuf', 'target': 'http://target.com/FUZZ', 'args': '-w /path/to/wordlist.txt -mc 200'}",
            "Spider: {'tool': 'gospider', 'target': 'https://target.com', 'args': '-d 2 -c 10'}",
            "Nuclei scan: {'tool': 'nuclei', 'target': 'https://target.com', 'args': '-t cves/'}",
            "Subdomain enum: {'tool': 'subfinder', 'target': 'target.com'}",
        ]

    def execute(self, **kwargs) -> ToolResult:
        """Execute penetration testing tool.

        Args:
            tool: Tool name
            target: Target URL/IP/domain
            args: Tool-specific arguments
            output_file: Optional output file

        Returns:
            ToolResult
        """
        tool_name = kwargs.get("tool", "").lower()
        target = kwargs.get("target", "")
        args = kwargs.get("args", "")
        output_file = kwargs.get("output_file")

        # Validate tool
        if tool_name not in self.SUPPORTED_TOOLS:
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error=f"Unknown tool '{tool_name}'. Supported: {', '.join(self.SUPPORTED_TOOLS.keys())}"
            )

        # Check if tool is available
        if not self.available_tools.get(tool_name, False):
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error=f"Tool '{tool_name}' is not installed. Install with: apt install {tool_name} or go install"
            )

        # Validate target
        if not target:
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error="No target specified"
            )

        # Build command
        try:
            full_command = self._build_command(tool_name, target, args, output_file)
        except ToolExecutionError as e:
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error=str(e)
            )

        # Execute
        logger.info(f"Executing: {' '.join(full_command)}")

        try:
            result = subprocess.run(
                full_command,
                cwd=str(self.working_dir),
                capture_output=True,
                timeout=600,  # 10 minute timeout
                text=True
            )

            output = result.stdout if result.stdout else result.stderr

            # Save output if requested
            saved_path = None
            if output_file:
                output_path = self.working_dir / output_file
                output_path.write_text(output)
                saved_path = str(output_path)
                logger.info(f"Saved output to: {output_path}")

            if result.returncode == 0 or output:  # Some tools return non-zero but still produce output
                return ToolResult(
                    status=ToolStatus.SUCCESS,
                    output=output[:5000],  # Limit output size
                    metadata={
                        "tool": tool_name,
                        "target": target,
                        "output_file": saved_path,
                        "full_output_length": len(output),
                        "return_code": result.returncode,
                        "command": ' '.join(full_command)
                    }
                )
            else:
                return ToolResult(
                    status=ToolStatus.ERROR,
                    output=output[:1000],
                    error=f"Tool exited with code {result.returncode}",
                    metadata={"tool": tool_name, "target": target}
                )

        except subprocess.TimeoutExpired:
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error="Command timeout (10 minutes). Operation aborted."
            )
        except Exception as e:
            logger.error(f"Pentest execution failed: {e}")
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error=f"Execution failed: {str(e)}"
            )

    def _build_command(
        self,
        tool_name: str,
        target: str,
        args: str,
        output_file: Optional[str]
    ) -> List[str]:
        """Build command list for subprocess.

        Args:
            tool_name: Tool to use
            target: Target
            args: Additional arguments
            output_file: Optional output file

        Returns:
            Command list

        Raises:
            ToolExecutionError: If command building fails
        """
        cmd = [tool_name]

        # Parse args
        if args:
            try:
                parsed_args = shlex.split(args)
                cmd.extend(parsed_args)
            except ValueError as e:
                raise ToolExecutionError(f"Invalid args syntax: {e}")

        # Tool-specific target handling
        if tool_name == "nmap":
            # Target goes at the end for nmap
            cmd.append(target)
            if output_file:
                output_path = self.working_dir / output_file
                cmd.extend(["-oN", str(output_path)])

        elif tool_name == "sqlmap":
            # SQLMap needs --url flag
            if "--url" not in args and "-u" not in args:
                cmd.extend(["--url", target])
            if "--batch" not in args:
                cmd.append("--batch")  # Non-interactive mode

        elif tool_name == "ffuf":
            # ffuf needs -u flag
            if "-u" not in args:
                cmd.extend(["-u", target])
            if output_file:
                output_path = self.working_dir / output_file
                cmd.extend(["-o", str(output_path)])

        elif tool_name == "gospider":
            # gospider needs -s flag
            if "-s" not in args:
                cmd.extend(["-s", target])
            if output_file:
                output_path = self.working_dir / output_file
                cmd.extend(["-o", str(self.working_dir)])

        elif tool_name == "nuclei":
            # nuclei needs -u for single target or -l for list
            if "-u" not in args and "-l" not in args:
                cmd.extend(["-u", target])
            if output_file:
                output_path = self.working_dir / output_file
                cmd.extend(["-o", str(output_path)])

        elif tool_name == "subfinder":
            # subfinder needs -d for domain
            if "-d" not in args:
                cmd.extend(["-d", target])
            if output_file:
                output_path = self.working_dir / output_file
                cmd.extend(["-o", str(output_path)])

        elif tool_name == "httpx":
            # httpx can take target via stdin or -u
            if "-u" not in args:
                cmd.extend(["-u", target])
            if output_file:
                output_path = self.working_dir / output_file
                cmd.extend(["-o", str(output_path)])

        return cmd

    @property
    def is_dangerous(self) -> bool:
        return True

    @property
    def requires_confirmation(self) -> bool:
        return False  # CEH certified, trusted user
