"""Enhanced penetration testing tool with AI-powered vulnerability scanning.

Inspired by Deep Eye architecture with independent implementation for RADIRA.
"""

import logging
from typing import Dict, List, Any, Optional
from pathlib import Path

from .base import BaseTool, ToolResult, ToolStatus
from config.settings import settings
from .pentest_engine.scanner_engine import VulnerabilityScanner
from .pentest_engine.recon.recon_engine import ReconEngine
from .pentest_engine.reporting.report_generator import ReportGenerator
from .pentest_engine.http_client import HTTPClient

logger = logging.getLogger(__name__)


class EnhancedPentestTool(BaseTool):
    """Enhanced penetration testing tool with AI-powered vulnerability scanning.

    Features:
    - AI-powered payload generation
    - Built-in vulnerability scanners (SQL Injection, XSS, SSRF, LFI, Command Injection, etc.)
    - Reconnaissance capabilities
    - Professional reporting (JSON, HTML, Text)
    - Smart crawling and URL discovery
    """

    def __init__(self, working_directory: Optional[str] = None):
        """Initialize enhanced pentest tool.

        Args:
            working_directory: Working directory for outputs
        """
        super().__init__()
        self.working_dir = Path(working_directory or settings.working_directory) / "pentest_output"
        self.working_dir.mkdir(parents=True, exist_ok=True)

        # Initialize report generator
        self.report_generator = ReportGenerator(str(self.working_dir))

    @property
    def name(self) -> str:
        return "enhanced_pentest"

    @property
    def description(self) -> str:
        return """AI-powered penetration testing and vulnerability scanning tool.

Features:
- Automated vulnerability scanning (SQL Injection, XSS, SSRF, LFI, Command Injection, Open Redirect)
- AI-powered payload generation for context-aware testing
- Smart web crawling and URL discovery
- Reconnaissance and information gathering
- Professional reports (JSON, HTML, Text)

Built-in scanners:
- SQL Injection (error-based, boolean-based, time-based)
- Cross-Site Scripting (XSS) - Reflected, Stored, DOM
- Server-Side Request Forgery (SSRF)
- Local File Inclusion (LFI)
- Command Injection
- Open Redirect

Report formats: JSON, HTML, Text
"""

    @property
    def parameters(self) -> Dict[str, Any]:
        return {
            "target_url": {
                "type": "string",
                "description": "Target URL to scan (e.g., http://example.com)",
                "required": True
            },
            "scan_type": {
                "type": "string",
                "description": "Type of scan: 'quick' (faster), 'full' (comprehensive), or 'recon' (reconnaissance only)",
                "required": False,
                "default": "full"
            },
            "crawl": {
                "type": "boolean",
                "description": "Whether to crawl the site to discover URLs (default: True)",
                "required": False,
                "default": True
            },
            "max_depth": {
                "type": "integer",
                "description": "Maximum crawl depth (default: 2)",
                "required": False,
                "default": 2
            },
            "modules": {
                "type": "string",
                "description": "Comma-separated list of modules to run (e.g., 'sql,xss'). Leave empty for all modules.",
                "required": False
            },
            "report_format": {
                "type": "string",
                "description": "Report format: 'json', 'html', 'text', or 'all' (default: 'all')",
                "required": False,
                "default": "all"
            },
            "verify_ssl": {
                "type": "boolean",
                "description": "Verify SSL certificates (default: False)",
                "required": False,
                "default": False
            },
            "proxy": {
                "type": "string",
                "description": "Proxy URL (e.g., http://127.0.0.1:8080)",
                "required": False
            }
        }

    @property
    def category(self) -> str:
        return "security"

    @property
    def examples(self) -> List[str]:
        return [
            "Full scan: {'target_url': 'http://testphp.vulnweb.com'}",
            "Quick scan: {'target_url': 'http://example.com', 'scan_type': 'quick', 'crawl': False}",
            "Reconnaissance only: {'target_url': 'http://example.com', 'scan_type': 'recon'}",
            "SQL and XSS only: {'target_url': 'http://example.com', 'modules': 'sql,xss'}",
            "With proxy: {'target_url': 'http://example.com', 'proxy': 'http://127.0.0.1:8080'}",
            "HTML report only: {'target_url': 'http://example.com', 'report_format': 'html'}",
        ]

    def execute(self, **kwargs) -> ToolResult:
        """Execute penetration testing scan.

        Args:
            target_url: Target URL
            scan_type: Type of scan ('quick', 'full', 'recon')
            crawl: Whether to crawl
            max_depth: Crawl depth
            modules: Modules to run
            report_format: Report format
            verify_ssl: Verify SSL
            proxy: Proxy URL

        Returns:
            ToolResult
        """
        target_url = kwargs.get("target_url", "")
        scan_type = kwargs.get("scan_type", "full")
        crawl = kwargs.get("crawl", True)
        max_depth = kwargs.get("max_depth", 2)
        modules_str = kwargs.get("modules", "")
        report_format = kwargs.get("report_format", "all")
        verify_ssl = kwargs.get("verify_ssl", False)
        proxy = kwargs.get("proxy")

        # Validate target URL
        if not target_url:
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error="No target URL specified"
            )

        if not HTTPClient.is_valid_url(target_url):
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error=f"Invalid URL: {target_url}"
            )

        logger.info(f"Starting {scan_type} scan of {target_url}")

        try:
            # Parse modules
            modules = None
            if modules_str:
                modules = [m.strip().lower() for m in modules_str.split(',')]

            # Setup proxies
            proxies = None
            if proxy:
                proxies = {"http": proxy, "https": proxy}

            # Reconnaissance only
            if scan_type == "recon":
                return self._perform_reconnaissance(target_url, verify_ssl, proxies, report_format)

            # Initialize scanner
            scanner = VulnerabilityScanner(
                target_url=target_url,
                verify_ssl=verify_ssl,
                proxies=proxies,
                max_depth=max_depth
            )

            # Perform scan
            quick_scan = (scan_type == "quick")
            scan_result = scanner.scan(
                quick_scan=quick_scan,
                crawl=crawl,
                modules=modules
            )

            # Optional reconnaissance
            recon_data = None
            if scan_type == "full":
                logger.info("Performing reconnaissance...")
                http_client = HTTPClient(verify_ssl=verify_ssl, proxies=proxies)
                recon_engine = ReconEngine(http_client)
                recon_data = recon_engine.gather(target_url)

            # Generate reports
            report_paths = self._generate_reports(scan_result, recon_data, report_format)

            # Prepare output
            summary = scan_result.get_summary()
            output = self._format_scan_output(scan_result, recon_data, report_paths)

            return ToolResult(
                status=ToolStatus.SUCCESS,
                output=output,
                metadata={
                    "target": target_url,
                    "scan_type": scan_type,
                    "vulnerabilities_found": summary['total'],
                    "critical": summary['critical'],
                    "high": summary['high'],
                    "medium": summary['medium'],
                    "low": summary['low'],
                    "info": summary['info'],
                    "urls_scanned": scan_result.urls_scanned,
                    "report_files": report_paths,
                    "scan_duration": scan_result.scan_duration
                }
            )

        except Exception as e:
            logger.error(f"Scan failed: {e}", exc_info=True)
            return ToolResult(
                status=ToolStatus.ERROR,
                output=None,
                error=f"Scan failed: {str(e)}"
            )

    def _perform_reconnaissance(
        self,
        target_url: str,
        verify_ssl: bool,
        proxies: Optional[Dict],
        report_format: str
    ) -> ToolResult:
        """Perform reconnaissance only.

        Args:
            target_url: Target URL
            verify_ssl: Verify SSL
            proxies: Proxy configuration
            report_format: Report format

        Returns:
            ToolResult
        """
        logger.info("Performing reconnaissance...")

        http_client = HTTPClient(verify_ssl=verify_ssl, proxies=proxies)
        recon_engine = ReconEngine(http_client)
        recon_data = recon_engine.gather(target_url)

        # Generate report (recon only)
        if report_format in ['json', 'all']:
            import json
            report_path = self.working_dir / "recon_report.json"
            with open(report_path, 'w') as f:
                json.dump(recon_data.to_dict(), f, indent=2)
            logger.info(f"Recon report saved: {report_path}")

        # Format output
        output = "=== RECONNAISSANCE RESULTS ===\n\n"
        output += f"Target: {recon_data.target}\n\n"

        if recon_data.dns_records:
            output += "DNS Records:\n"
            for record_type, records in recon_data.dns_records.items():
                output += f"  {record_type}: {', '.join(records)}\n"
            output += "\n"

        if recon_data.tech_stack:
            output += f"Technologies: {', '.join(recon_data.tech_stack)}\n\n"

        if recon_data.endpoints:
            output += f"Endpoints Found: {len(recon_data.endpoints)}\n"
            for endpoint in recon_data.endpoints[:10]:
                output += f"  {endpoint}\n"
            output += "\n"

        if recon_data.headers:
            output += "Security Headers:\n"
            for header, value in recon_data.headers.items():
                output += f"  {header}: {value}\n"

        return ToolResult(
            status=ToolStatus.SUCCESS,
            output=output,
            metadata={"recon_data": recon_data.to_dict()}
        )

    def _generate_reports(
        self,
        scan_result,
        recon_data,
        report_format: str
    ) -> Dict[str, str]:
        """Generate scan reports.

        Args:
            scan_result: Scan results
            recon_data: Recon data
            report_format: Format(s) to generate

        Returns:
            Dictionary of format -> file path
        """
        report_paths = {}

        if report_format == "all":
            report_paths = self.report_generator.generate_all_formats(scan_result, recon_data)
        elif report_format == "json":
            report_paths['json'] = self.report_generator.generate_json_report(scan_result, recon_data)
        elif report_format == "html":
            report_paths['html'] = self.report_generator.generate_html_report(scan_result, recon_data)
        elif report_format == "text":
            report_paths['text'] = self.report_generator.generate_text_report(scan_result, recon_data)

        return report_paths

    @staticmethod
    def _format_scan_output(scan_result, recon_data, report_paths) -> str:
        """Format scan output for display.

        Args:
            scan_result: Scan results
            recon_data: Recon data
            report_paths: Generated report paths

        Returns:
            Formatted output string
        """
        summary = scan_result.get_summary()

        output = "=== PENETRATION TEST RESULTS ===\n\n"
        output += f"Target: {scan_result.target}\n"
        output += f"Duration: {scan_result.scan_duration:.2f} seconds\n"
        output += f"URLs Scanned: {scan_result.urls_scanned}\n\n"

        output += "VULNERABILITY SUMMARY:\n"
        output += f"  Total: {summary['total']}\n"
        output += f"  Critical: {summary['critical']}\n"
        output += f"  High: {summary['high']}\n"
        output += f"  Medium: {summary['medium']}\n"
        output += f"  Low: {summary['low']}\n"
        output += f"  Info: {summary['info']}\n\n"

        # Top vulnerabilities
        if scan_result.vulnerabilities:
            output += "TOP FINDINGS:\n"
            for i, vuln in enumerate(scan_result.vulnerabilities[:5], 1):
                output += f"\n[{i}] {vuln.type.value.upper()} ({vuln.severity.value.upper()})\n"
                output += f"    URL: {vuln.url}\n"
                if vuln.parameter:
                    output += f"    Parameter: {vuln.parameter}\n"
                output += f"    {vuln.description[:100]}...\n"

        # Reconnaissance summary
        if recon_data and recon_data.tech_stack:
            output += f"\nTECHNOLOGIES DETECTED: {', '.join(recon_data.tech_stack[:5])}\n"

        # Report files
        if report_paths:
            output += "\nREPORT FILES:\n"
            for format_type, path in report_paths.items():
                output += f"  {format_type.upper()}: {path}\n"

        return output

    @property
    def is_dangerous(self) -> bool:
        return True

    @property
    def requires_confirmation(self) -> bool:
        return False  # Authorized security testing
